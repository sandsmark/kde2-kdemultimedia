/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#ifndef EQUALIZER_H
#define EQUALIZER_H

#include "common.h"

// includes of other idl definitions
#include "artsflow.h"

namespace Arts {
class Equalizer;

class Equalizer_base : virtual public Arts::StereoEffect_base {
public:
	static unsigned long _IID; // interface ID

	static Equalizer_base *_create(const std::string& subClass = "Arts::Equalizer");
	static Equalizer_base *_fromString(std::string objectref);
	static Equalizer_base *_fromReference(Arts::ObjectReference ref, bool needcopy);

	inline Equalizer_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual std::vector<std::string> _defaultPortsIn() const;
	virtual std::vector<std::string> _defaultPortsOut() const;

	void *_cast(unsigned long iid);

	virtual std::vector<float> * levelCenters() = 0;
	virtual void levelCenters(const std::vector<float>& newValue) = 0;
	virtual std::vector<float> * levelWidths() = 0;
	virtual void levelWidths(const std::vector<float>& newValue) = 0;
	virtual std::vector<float> * levels() = 0;
	virtual void levels(const std::vector<float>& newValue) = 0;
	virtual long bands() = 0;
	virtual void bands(long newValue) = 0;
	virtual long enabled() = 0;
	virtual void enabled(long newValue) = 0;
	virtual float preamp() = 0;
	virtual void preamp(float newValue) = 0;
	virtual void set(const std::vector<float>& levels, const std::vector<float>& centers, const std::vector<float>& widths) = 0;
};

class Equalizer_stub : virtual public Equalizer_base, virtual public Arts::StereoEffect_stub {
protected:
	Equalizer_stub();

public:
	Equalizer_stub(Arts::Connection *connection, long objectID);

	std::vector<float> * levelCenters();
	void levelCenters(const std::vector<float>& newValue);
	std::vector<float> * levelWidths();
	void levelWidths(const std::vector<float>& newValue);
	std::vector<float> * levels();
	void levels(const std::vector<float>& newValue);
	long bands();
	void bands(long newValue);
	long enabled();
	void enabled(long newValue);
	float preamp();
	void preamp(float newValue);
	void set(const std::vector<float>& levels, const std::vector<float>& centers, const std::vector<float>& widths);
};

class Equalizer_skel : virtual public Equalizer_base, virtual public Arts::StereoEffect_skel {
protected:
	// emitters for change notifications
	inline void levelCenters_changed(const std::vector<float>& newValue) {
		_emit_changed("levelCenters_changed",newValue);
	}
	inline void levelWidths_changed(const std::vector<float>& newValue) {
		_emit_changed("levelWidths_changed",newValue);
	}
	inline void levels_changed(const std::vector<float>& newValue) {
		_emit_changed("levels_changed",newValue);
	}
	inline void bands_changed(long newValue) {
		_emit_changed("bands_changed",newValue);
	}
	inline void enabled_changed(long newValue) {
		_emit_changed("enabled_changed",newValue);
	}
	inline void preamp_changed(float newValue) {
		_emit_changed("preamp_changed",newValue);
	}

public:
	Equalizer_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	bool _isCompatibleWith(const std::string& interfacename);
	void _buildMethodTable();
	void dispatch(Arts::Buffer *request, Arts::Buffer *result,long methodID);
};

};
#include "reference.h"
namespace Arts {
class Equalizer : public Arts::Object {
private:
	static Arts::Object_base* _Creator();
	Equalizer_base *_cache;
	inline Equalizer_base *_method_call() {
		_pool->checkcreate();
		if(_pool->base) {
			_cache=(Equalizer_base *)_pool->base->_cast(Equalizer_base::_IID);
			assert(_cache);
		}
		return _cache;
	}

protected:
	inline Equalizer(Equalizer_base* b) : Arts::Object(b), _cache(0) {}


public:
	typedef Equalizer_base _base_class;

	inline Equalizer() : Arts::Object(_Creator), _cache(0) {}
	inline Equalizer(const Arts::SubClass& s) :
		Arts::Object(Equalizer_base::_create(s.string())), _cache(0) {}
	inline Equalizer(const Arts::Reference &r) :
		Arts::Object(r.isString()?(Equalizer_base::_fromString(r.string())):(Equalizer_base::_fromReference(r.reference(),true))), _cache(0) {}
	inline Equalizer(const Arts::DynamicCast& c) : Arts::Object(Equalizer_base::_fromString(c.object().toString())), _cache(0) {}
	inline Equalizer(const Equalizer& target) : Arts::Object(target._pool), _cache(target._cache) {}
	inline Equalizer(Arts::Object::Pool& p) : Arts::Object(p), _cache(0) {}
	inline static Equalizer null() {return Equalizer((Equalizer_base*)0);}
	inline static Equalizer _from_base(Equalizer_base* b) {return Equalizer(b);}
	inline Equalizer& operator=(const Equalizer& target) {
		if (_pool == target._pool) return *this;
		_pool->Dec();
		_pool = target._pool;
		_cache = target._cache;
		_pool->Inc();
		return *this;
	}
	inline operator Arts::StereoEffect() const { return Arts::StereoEffect(*_pool); }
	inline operator Arts::SynthModule() const { return Arts::SynthModule(*_pool); }
	inline Equalizer_base* _base() {return _cache?_cache:_method_call();}

	inline Arts::AutoSuspendState autoSuspend();
	inline void start();
	inline void stop();
	inline void streamInit();
	inline void streamStart();
	inline void streamEnd();
	inline std::vector<float> * levelCenters();
	inline void levelCenters(const std::vector<float>& _newValue);
	inline std::vector<float> * levelWidths();
	inline void levelWidths(const std::vector<float>& _newValue);
	inline std::vector<float> * levels();
	inline void levels(const std::vector<float>& _newValue);
	inline long bands();
	inline void bands(long _newValue);
	inline long enabled();
	inline void enabled(long _newValue);
	inline float preamp();
	inline void preamp(float _newValue);
	inline void set(const std::vector<float>& levels, const std::vector<float>& centers, const std::vector<float>& widths);
};

// Forward wrapper calls to _base classes:

inline Arts::AutoSuspendState Arts::Equalizer::autoSuspend()
{
	return _cache?static_cast<Arts::SynthModule_base*>(_cache)->autoSuspend():static_cast<Arts::SynthModule_base*>(_method_call())->autoSuspend();
}

inline void Arts::Equalizer::start()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->start():static_cast<Arts::SynthModule_base*>(_method_call())->start();
}

inline void Arts::Equalizer::stop()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->stop():static_cast<Arts::SynthModule_base*>(_method_call())->stop();
}

inline void Arts::Equalizer::streamInit()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamInit():static_cast<Arts::SynthModule_base*>(_method_call())->streamInit();
}

inline void Arts::Equalizer::streamStart()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamStart():static_cast<Arts::SynthModule_base*>(_method_call())->streamStart();
}

inline void Arts::Equalizer::streamEnd()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamEnd():static_cast<Arts::SynthModule_base*>(_method_call())->streamEnd();
}

inline std::vector<float> * Arts::Equalizer::levelCenters()
{
	return _cache?static_cast<Arts::Equalizer_base*>(_cache)->levelCenters():static_cast<Arts::Equalizer_base*>(_method_call())->levelCenters();
}

inline void Arts::Equalizer::levelCenters(const std::vector<float>& _newValue)
{
	 _cache?static_cast<Arts::Equalizer_base*>(_cache)->levelCenters(_newValue):static_cast<Arts::Equalizer_base*>(_method_call())->levelCenters(_newValue);
}

inline std::vector<float> * Arts::Equalizer::levelWidths()
{
	return _cache?static_cast<Arts::Equalizer_base*>(_cache)->levelWidths():static_cast<Arts::Equalizer_base*>(_method_call())->levelWidths();
}

inline void Arts::Equalizer::levelWidths(const std::vector<float>& _newValue)
{
	 _cache?static_cast<Arts::Equalizer_base*>(_cache)->levelWidths(_newValue):static_cast<Arts::Equalizer_base*>(_method_call())->levelWidths(_newValue);
}

inline std::vector<float> * Arts::Equalizer::levels()
{
	return _cache?static_cast<Arts::Equalizer_base*>(_cache)->levels():static_cast<Arts::Equalizer_base*>(_method_call())->levels();
}

inline void Arts::Equalizer::levels(const std::vector<float>& _newValue)
{
	 _cache?static_cast<Arts::Equalizer_base*>(_cache)->levels(_newValue):static_cast<Arts::Equalizer_base*>(_method_call())->levels(_newValue);
}

inline long Arts::Equalizer::bands()
{
	return _cache?static_cast<Arts::Equalizer_base*>(_cache)->bands():static_cast<Arts::Equalizer_base*>(_method_call())->bands();
}

inline void Arts::Equalizer::bands(long _newValue)
{
	 _cache?static_cast<Arts::Equalizer_base*>(_cache)->bands(_newValue):static_cast<Arts::Equalizer_base*>(_method_call())->bands(_newValue);
}

inline long Arts::Equalizer::enabled()
{
	return _cache?static_cast<Arts::Equalizer_base*>(_cache)->enabled():static_cast<Arts::Equalizer_base*>(_method_call())->enabled();
}

inline void Arts::Equalizer::enabled(long _newValue)
{
	 _cache?static_cast<Arts::Equalizer_base*>(_cache)->enabled(_newValue):static_cast<Arts::Equalizer_base*>(_method_call())->enabled(_newValue);
}

inline float Arts::Equalizer::preamp()
{
	return _cache?static_cast<Arts::Equalizer_base*>(_cache)->preamp():static_cast<Arts::Equalizer_base*>(_method_call())->preamp();
}

inline void Arts::Equalizer::preamp(float _newValue)
{
	 _cache?static_cast<Arts::Equalizer_base*>(_cache)->preamp(_newValue):static_cast<Arts::Equalizer_base*>(_method_call())->preamp(_newValue);
}

inline void Arts::Equalizer::set(const std::vector<float>& levels, const std::vector<float>& centers, const std::vector<float>& widths)
{
	 _cache?static_cast<Arts::Equalizer_base*>(_cache)->set(levels, centers, widths):static_cast<Arts::Equalizer_base*>(_method_call())->set(levels, centers, widths);
}

};
#endif /* EQUALIZER_H */
