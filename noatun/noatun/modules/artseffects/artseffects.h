/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#ifndef ARTSEFFECTS_H
#define ARTSEFFECTS_H

#include "common.h"

// includes of other idl definitions
#include "artsflow.h"
#include "artsgui.h"

class ExtraStereo;
class VoiceRemoval;
class RawWriter;
class ExtraStereoGuiFactory;

class ExtraStereo_base : virtual public Arts::StereoEffect_base {
public:
	static unsigned long _IID; // interface ID

	static ExtraStereo_base *_create(const std::string& subClass = "ExtraStereo");
	static ExtraStereo_base *_fromString(std::string objectref);
	static ExtraStereo_base *_fromReference(Arts::ObjectReference ref, bool needcopy);

	static ExtraStereo_base *_fromDynamicCast(const Arts::Object& object);
	inline ExtraStereo_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual std::vector<std::string> _defaultPortsIn() const;
	virtual std::vector<std::string> _defaultPortsOut() const;

	void *_cast(unsigned long iid);

	virtual float intensity() = 0;
	virtual void intensity(float newValue) = 0;
};

class ExtraStereo_stub : virtual public ExtraStereo_base, virtual public Arts::StereoEffect_stub {
protected:
	ExtraStereo_stub();

public:
	ExtraStereo_stub(Arts::Connection *connection, long objectID);

	float intensity();
	void intensity(float newValue);
};

class ExtraStereo_skel : virtual public ExtraStereo_base, virtual public Arts::StereoEffect_skel {
protected:
	// emitters for change notifications
	inline void intensity_changed(float newValue) {
		_emit_changed("intensity_changed",newValue);
	}

public:
	ExtraStereo_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	bool _isCompatibleWith(const std::string& interfacename);
	void _buildMethodTable();
	void dispatch(Arts::Buffer *request, Arts::Buffer *result,long methodID);
};

#include "reference.h"
class ExtraStereo : public Arts::Object {
private:
	static Arts::Object_base* _Creator();
	ExtraStereo_base *_cache;
	inline ExtraStereo_base *_method_call() {
		_pool->checkcreate();
		if(_pool->base) {
			_cache=(ExtraStereo_base *)_pool->base->_cast(ExtraStereo_base::_IID);
			assert(_cache);
		}
		return _cache;
	}

protected:
	inline ExtraStereo(ExtraStereo_base* b) : Arts::Object(b), _cache(0) {}


public:
	typedef ExtraStereo_base _base_class;

	inline ExtraStereo() : Arts::Object(_Creator), _cache(0) {}
	inline ExtraStereo(const Arts::SubClass& s) :
		Arts::Object(ExtraStereo_base::_create(s.string())), _cache(0) {}
	inline ExtraStereo(const Arts::Reference &r) :
		Arts::Object(r.isString()?(ExtraStereo_base::_fromString(r.string())):(ExtraStereo_base::_fromReference(r.reference(),true))), _cache(0) {}
	inline ExtraStereo(const Arts::DynamicCast& c) : Arts::Object(ExtraStereo_base::_fromDynamicCast(c.object())), _cache(0) {}
	inline ExtraStereo(const ExtraStereo& target) : Arts::Object(target._pool), _cache(target._cache) {}
	inline ExtraStereo(Arts::Object::Pool& p) : Arts::Object(p), _cache(0) {}
	inline static ExtraStereo null() {return ExtraStereo((ExtraStereo_base*)0);}
	inline static ExtraStereo _from_base(ExtraStereo_base* b) {return ExtraStereo(b);}
	inline ExtraStereo& operator=(const ExtraStereo& target) {
		if (_pool == target._pool) return *this;
		_pool->Dec();
		_pool = target._pool;
		_cache = target._cache;
		_pool->Inc();
		return *this;
	}
	inline operator Arts::StereoEffect() const { return Arts::StereoEffect(*_pool); }
	inline operator Arts::SynthModule() const { return Arts::SynthModule(*_pool); }
	inline ExtraStereo_base* _base() {return _cache?_cache:_method_call();}

	inline Arts::AutoSuspendState autoSuspend();
	inline void start();
	inline void stop();
	inline void streamInit();
	inline void streamStart();
	inline void streamEnd();
	inline float intensity();
	inline void intensity(float _newValue);
};

class VoiceRemoval_base : virtual public Arts::StereoEffect_base {
public:
	static unsigned long _IID; // interface ID

	static VoiceRemoval_base *_create(const std::string& subClass = "VoiceRemoval");
	static VoiceRemoval_base *_fromString(std::string objectref);
	static VoiceRemoval_base *_fromReference(Arts::ObjectReference ref, bool needcopy);

	static VoiceRemoval_base *_fromDynamicCast(const Arts::Object& object);
	inline VoiceRemoval_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual std::vector<std::string> _defaultPortsIn() const;
	virtual std::vector<std::string> _defaultPortsOut() const;

	void *_cast(unsigned long iid);

};

class VoiceRemoval_stub : virtual public VoiceRemoval_base, virtual public Arts::StereoEffect_stub {
protected:
	VoiceRemoval_stub();

public:
	VoiceRemoval_stub(Arts::Connection *connection, long objectID);

};

class VoiceRemoval_skel : virtual public VoiceRemoval_base, virtual public Arts::StereoEffect_skel {
public:
	VoiceRemoval_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	bool _isCompatibleWith(const std::string& interfacename);
	void _buildMethodTable();
	void dispatch(Arts::Buffer *request, Arts::Buffer *result,long methodID);
};

#include "reference.h"
class VoiceRemoval : public Arts::Object {
private:
	static Arts::Object_base* _Creator();
	VoiceRemoval_base *_cache;
	inline VoiceRemoval_base *_method_call() {
		_pool->checkcreate();
		if(_pool->base) {
			_cache=(VoiceRemoval_base *)_pool->base->_cast(VoiceRemoval_base::_IID);
			assert(_cache);
		}
		return _cache;
	}

protected:
	inline VoiceRemoval(VoiceRemoval_base* b) : Arts::Object(b), _cache(0) {}


public:
	typedef VoiceRemoval_base _base_class;

	inline VoiceRemoval() : Arts::Object(_Creator), _cache(0) {}
	inline VoiceRemoval(const Arts::SubClass& s) :
		Arts::Object(VoiceRemoval_base::_create(s.string())), _cache(0) {}
	inline VoiceRemoval(const Arts::Reference &r) :
		Arts::Object(r.isString()?(VoiceRemoval_base::_fromString(r.string())):(VoiceRemoval_base::_fromReference(r.reference(),true))), _cache(0) {}
	inline VoiceRemoval(const Arts::DynamicCast& c) : Arts::Object(VoiceRemoval_base::_fromDynamicCast(c.object())), _cache(0) {}
	inline VoiceRemoval(const VoiceRemoval& target) : Arts::Object(target._pool), _cache(target._cache) {}
	inline VoiceRemoval(Arts::Object::Pool& p) : Arts::Object(p), _cache(0) {}
	inline static VoiceRemoval null() {return VoiceRemoval((VoiceRemoval_base*)0);}
	inline static VoiceRemoval _from_base(VoiceRemoval_base* b) {return VoiceRemoval(b);}
	inline VoiceRemoval& operator=(const VoiceRemoval& target) {
		if (_pool == target._pool) return *this;
		_pool->Dec();
		_pool = target._pool;
		_cache = target._cache;
		_pool->Inc();
		return *this;
	}
	inline operator Arts::StereoEffect() const { return Arts::StereoEffect(*_pool); }
	inline operator Arts::SynthModule() const { return Arts::SynthModule(*_pool); }
	inline VoiceRemoval_base* _base() {return _cache?_cache:_method_call();}

	inline Arts::AutoSuspendState autoSuspend();
	inline void start();
	inline void stop();
	inline void streamInit();
	inline void streamStart();
	inline void streamEnd();
};

class RawWriter_base : virtual public Arts::StereoEffect_base {
public:
	static unsigned long _IID; // interface ID

	static RawWriter_base *_create(const std::string& subClass = "RawWriter");
	static RawWriter_base *_fromString(std::string objectref);
	static RawWriter_base *_fromReference(Arts::ObjectReference ref, bool needcopy);

	static RawWriter_base *_fromDynamicCast(const Arts::Object& object);
	inline RawWriter_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual std::vector<std::string> _defaultPortsIn() const;
	virtual std::vector<std::string> _defaultPortsOut() const;

	void *_cast(unsigned long iid);

};

class RawWriter_stub : virtual public RawWriter_base, virtual public Arts::StereoEffect_stub {
protected:
	RawWriter_stub();

public:
	RawWriter_stub(Arts::Connection *connection, long objectID);

};

class RawWriter_skel : virtual public RawWriter_base, virtual public Arts::StereoEffect_skel {
public:
	RawWriter_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	bool _isCompatibleWith(const std::string& interfacename);
	void _buildMethodTable();
	void dispatch(Arts::Buffer *request, Arts::Buffer *result,long methodID);
};

#include "reference.h"
class RawWriter : public Arts::Object {
private:
	static Arts::Object_base* _Creator();
	RawWriter_base *_cache;
	inline RawWriter_base *_method_call() {
		_pool->checkcreate();
		if(_pool->base) {
			_cache=(RawWriter_base *)_pool->base->_cast(RawWriter_base::_IID);
			assert(_cache);
		}
		return _cache;
	}

protected:
	inline RawWriter(RawWriter_base* b) : Arts::Object(b), _cache(0) {}


public:
	typedef RawWriter_base _base_class;

	inline RawWriter() : Arts::Object(_Creator), _cache(0) {}
	inline RawWriter(const Arts::SubClass& s) :
		Arts::Object(RawWriter_base::_create(s.string())), _cache(0) {}
	inline RawWriter(const Arts::Reference &r) :
		Arts::Object(r.isString()?(RawWriter_base::_fromString(r.string())):(RawWriter_base::_fromReference(r.reference(),true))), _cache(0) {}
	inline RawWriter(const Arts::DynamicCast& c) : Arts::Object(RawWriter_base::_fromDynamicCast(c.object())), _cache(0) {}
	inline RawWriter(const RawWriter& target) : Arts::Object(target._pool), _cache(target._cache) {}
	inline RawWriter(Arts::Object::Pool& p) : Arts::Object(p), _cache(0) {}
	inline static RawWriter null() {return RawWriter((RawWriter_base*)0);}
	inline static RawWriter _from_base(RawWriter_base* b) {return RawWriter(b);}
	inline RawWriter& operator=(const RawWriter& target) {
		if (_pool == target._pool) return *this;
		_pool->Dec();
		_pool = target._pool;
		_cache = target._cache;
		_pool->Inc();
		return *this;
	}
	inline operator Arts::StereoEffect() const { return Arts::StereoEffect(*_pool); }
	inline operator Arts::SynthModule() const { return Arts::SynthModule(*_pool); }
	inline RawWriter_base* _base() {return _cache?_cache:_method_call();}

	inline Arts::AutoSuspendState autoSuspend();
	inline void start();
	inline void stop();
	inline void streamInit();
	inline void streamStart();
	inline void streamEnd();
};

class ExtraStereoGuiFactory_base : virtual public Arts::GuiFactory_base {
public:
	static unsigned long _IID; // interface ID

	static ExtraStereoGuiFactory_base *_create(const std::string& subClass = "ExtraStereoGuiFactory");
	static ExtraStereoGuiFactory_base *_fromString(std::string objectref);
	static ExtraStereoGuiFactory_base *_fromReference(Arts::ObjectReference ref, bool needcopy);

	static ExtraStereoGuiFactory_base *_fromDynamicCast(const Arts::Object& object);
	inline ExtraStereoGuiFactory_base *_copy() {
		assert(_refCnt > 0);
		_refCnt++;
		return this;
	}

	virtual std::vector<std::string> _defaultPortsIn() const;
	virtual std::vector<std::string> _defaultPortsOut() const;

	void *_cast(unsigned long iid);

};

class ExtraStereoGuiFactory_stub : virtual public ExtraStereoGuiFactory_base, virtual public Arts::GuiFactory_stub {
protected:
	ExtraStereoGuiFactory_stub();

public:
	ExtraStereoGuiFactory_stub(Arts::Connection *connection, long objectID);

};

class ExtraStereoGuiFactory_skel : virtual public ExtraStereoGuiFactory_base, virtual public Arts::GuiFactory_skel {
public:
	ExtraStereoGuiFactory_skel();

	static std::string _interfaceNameSkel();
	std::string _interfaceName();
	bool _isCompatibleWith(const std::string& interfacename);
	void _buildMethodTable();
	void dispatch(Arts::Buffer *request, Arts::Buffer *result,long methodID);
};

#include "reference.h"
class ExtraStereoGuiFactory : public Arts::Object {
private:
	static Arts::Object_base* _Creator();
	ExtraStereoGuiFactory_base *_cache;
	inline ExtraStereoGuiFactory_base *_method_call() {
		_pool->checkcreate();
		if(_pool->base) {
			_cache=(ExtraStereoGuiFactory_base *)_pool->base->_cast(ExtraStereoGuiFactory_base::_IID);
			assert(_cache);
		}
		return _cache;
	}

protected:
	inline ExtraStereoGuiFactory(ExtraStereoGuiFactory_base* b) : Arts::Object(b), _cache(0) {}


public:
	typedef ExtraStereoGuiFactory_base _base_class;

	inline ExtraStereoGuiFactory() : Arts::Object(_Creator), _cache(0) {}
	inline ExtraStereoGuiFactory(const Arts::SubClass& s) :
		Arts::Object(ExtraStereoGuiFactory_base::_create(s.string())), _cache(0) {}
	inline ExtraStereoGuiFactory(const Arts::Reference &r) :
		Arts::Object(r.isString()?(ExtraStereoGuiFactory_base::_fromString(r.string())):(ExtraStereoGuiFactory_base::_fromReference(r.reference(),true))), _cache(0) {}
	inline ExtraStereoGuiFactory(const Arts::DynamicCast& c) : Arts::Object(ExtraStereoGuiFactory_base::_fromDynamicCast(c.object())), _cache(0) {}
	inline ExtraStereoGuiFactory(const ExtraStereoGuiFactory& target) : Arts::Object(target._pool), _cache(target._cache) {}
	inline ExtraStereoGuiFactory(Arts::Object::Pool& p) : Arts::Object(p), _cache(0) {}
	inline static ExtraStereoGuiFactory null() {return ExtraStereoGuiFactory((ExtraStereoGuiFactory_base*)0);}
	inline static ExtraStereoGuiFactory _from_base(ExtraStereoGuiFactory_base* b) {return ExtraStereoGuiFactory(b);}
	inline ExtraStereoGuiFactory& operator=(const ExtraStereoGuiFactory& target) {
		if (_pool == target._pool) return *this;
		_pool->Dec();
		_pool = target._pool;
		_cache = target._cache;
		_pool->Inc();
		return *this;
	}
	inline operator Arts::GuiFactory() const { return Arts::GuiFactory(*_pool); }
	inline ExtraStereoGuiFactory_base* _base() {return _cache?_cache:_method_call();}

	inline Arts::Widget createGui(Arts::Object runningObject);
};

// Forward wrapper calls to _base classes:

inline Arts::AutoSuspendState ExtraStereo::autoSuspend()
{
	return _cache?static_cast<Arts::SynthModule_base*>(_cache)->autoSuspend():static_cast<Arts::SynthModule_base*>(_method_call())->autoSuspend();
}

inline void ExtraStereo::start()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->start():static_cast<Arts::SynthModule_base*>(_method_call())->start();
}

inline void ExtraStereo::stop()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->stop():static_cast<Arts::SynthModule_base*>(_method_call())->stop();
}

inline void ExtraStereo::streamInit()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamInit():static_cast<Arts::SynthModule_base*>(_method_call())->streamInit();
}

inline void ExtraStereo::streamStart()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamStart():static_cast<Arts::SynthModule_base*>(_method_call())->streamStart();
}

inline void ExtraStereo::streamEnd()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamEnd():static_cast<Arts::SynthModule_base*>(_method_call())->streamEnd();
}

inline float ExtraStereo::intensity()
{
	return _cache?static_cast<ExtraStereo_base*>(_cache)->intensity():static_cast<ExtraStereo_base*>(_method_call())->intensity();
}

inline void ExtraStereo::intensity(float _newValue)
{
	 _cache?static_cast<ExtraStereo_base*>(_cache)->intensity(_newValue):static_cast<ExtraStereo_base*>(_method_call())->intensity(_newValue);
}

inline Arts::AutoSuspendState VoiceRemoval::autoSuspend()
{
	return _cache?static_cast<Arts::SynthModule_base*>(_cache)->autoSuspend():static_cast<Arts::SynthModule_base*>(_method_call())->autoSuspend();
}

inline void VoiceRemoval::start()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->start():static_cast<Arts::SynthModule_base*>(_method_call())->start();
}

inline void VoiceRemoval::stop()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->stop():static_cast<Arts::SynthModule_base*>(_method_call())->stop();
}

inline void VoiceRemoval::streamInit()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamInit():static_cast<Arts::SynthModule_base*>(_method_call())->streamInit();
}

inline void VoiceRemoval::streamStart()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamStart():static_cast<Arts::SynthModule_base*>(_method_call())->streamStart();
}

inline void VoiceRemoval::streamEnd()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamEnd():static_cast<Arts::SynthModule_base*>(_method_call())->streamEnd();
}

inline Arts::AutoSuspendState RawWriter::autoSuspend()
{
	return _cache?static_cast<Arts::SynthModule_base*>(_cache)->autoSuspend():static_cast<Arts::SynthModule_base*>(_method_call())->autoSuspend();
}

inline void RawWriter::start()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->start():static_cast<Arts::SynthModule_base*>(_method_call())->start();
}

inline void RawWriter::stop()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->stop():static_cast<Arts::SynthModule_base*>(_method_call())->stop();
}

inline void RawWriter::streamInit()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamInit():static_cast<Arts::SynthModule_base*>(_method_call())->streamInit();
}

inline void RawWriter::streamStart()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamStart():static_cast<Arts::SynthModule_base*>(_method_call())->streamStart();
}

inline void RawWriter::streamEnd()
{
	 _cache?static_cast<Arts::SynthModule_base*>(_cache)->streamEnd():static_cast<Arts::SynthModule_base*>(_method_call())->streamEnd();
}

inline Arts::Widget ExtraStereoGuiFactory::createGui(Arts::Object runningObject)
{
	return _cache?static_cast<Arts::GuiFactory_base*>(_cache)->createGui(runningObject):static_cast<Arts::GuiFactory_base*>(_method_call())->createGui(runningObject);
}

#endif /* ARTSEFFECTS_H */
