/* this file was generated by the MCOP idl compiler - DO NOT EDIT */

#include "artseffects.h"

// Implementation
ExtraStereo_base *ExtraStereo_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	ExtraStereo_base *castedObject = (ExtraStereo_base *)skel->_cast(ExtraStereo_base::_IID);
	assert(castedObject);
	return castedObject;
}

ExtraStereo_base *ExtraStereo_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return ExtraStereo_base::_fromReference(r,true);
	return 0;
}

ExtraStereo_base *ExtraStereo_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	ExtraStereo_base *castedObject = (ExtraStereo_base *)object._base()->_cast(ExtraStereo_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

ExtraStereo_base *ExtraStereo_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	ExtraStereo_base *result;
	result = (ExtraStereo_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"ExtraStereo");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new ExtraStereo_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("ExtraStereo")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> ExtraStereo_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("inleft");
	ret.push_back("inright");
	return ret;
}
std::vector<std::string> ExtraStereo_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outleft");
	ret.push_back("outright");
	return ret;
}

void *ExtraStereo_base::_cast(unsigned long iid)
{
	if(iid == ExtraStereo_base::_IID) return (ExtraStereo_base *)this;
	if(iid == Arts::StereoEffect_base::_IID) return (Arts::StereoEffect_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

ExtraStereo_stub::ExtraStereo_stub()
{
	// constructor for subclasses (don't use directly)
}

ExtraStereo_stub::ExtraStereo_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

float ExtraStereo_stub::intensity()
{
	long methodID = _lookupMethodFast("method:0000000f5f6765745f696e74656e736974790000000006666c6f617400000000020000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(!result) return 0.0; // error occured
	float returnCode = result->readFloat();
	delete result;
	return returnCode;
}

void ExtraStereo_stub::intensity(float newValue)
{
	long methodID = _lookupMethodFast("method:0000000f5f7365745f696e74656e736974790000000005766f696400000000020000000100000006666c6f617400000000096e657756616c7565000000000000000000");
	long requestID;
	Arts::Buffer *request, *result;
	request = Arts::Dispatcher::the()->createRequest(requestID,_objectID,methodID);
	request->writeFloat(newValue);
	request->patchLength();
	_connection->qSendBuffer(request);

	result = Arts::Dispatcher::the()->waitForResult(requestID,_connection);
	if(result) delete result;
}

std::string ExtraStereo_skel::_interfaceName()
{
	return "ExtraStereo";
}

bool ExtraStereo_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "ExtraStereo") return true;
	if (interfacename == "Arts::StereoEffect") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string ExtraStereo_skel::_interfaceNameSkel()
{
	return "ExtraStereo";
}

// _get_intensity
static void _dispatch__ExtraStereo_00(void *object, Arts::Buffer *, Arts::Buffer *result)
{
	result->writeFloat(((ExtraStereo_skel *)object)->intensity());
}

// _set_intensity
static void _dispatch__ExtraStereo_01(void *object, Arts::Buffer *request, Arts::Buffer *)
{
	float newValue = request->readFloat();
	((ExtraStereo_skel *)object)->intensity(newValue);
}

void ExtraStereo_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:0000000f5f6765745f696e74656e736974790000000006666c6f61"
        "74000000000200000000000000000000000f5f7365745f696e74656e7369747900"
        "00000005766f696400000000020000000100000006666c6f617400000000096e65"
        "7756616c7565000000000000000000",
		"MethodTable"
	);
	_addMethod(_dispatch__ExtraStereo_00,this,Arts::MethodDef(m));
	_addMethod(_dispatch__ExtraStereo_01,this,Arts::MethodDef(m));
	Arts::StereoEffect_skel::_buildMethodTable();
}

ExtraStereo_skel::ExtraStereo_skel()
{
}

Arts::Object_base* ExtraStereo::_Creator() {
	return ExtraStereo_base::_create();
}

unsigned long ExtraStereo_base::_IID = Arts::MCOPUtils::makeIID("ExtraStereo");

VoiceRemoval_base *VoiceRemoval_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	VoiceRemoval_base *castedObject = (VoiceRemoval_base *)skel->_cast(VoiceRemoval_base::_IID);
	assert(castedObject);
	return castedObject;
}

VoiceRemoval_base *VoiceRemoval_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return VoiceRemoval_base::_fromReference(r,true);
	return 0;
}

VoiceRemoval_base *VoiceRemoval_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	VoiceRemoval_base *castedObject = (VoiceRemoval_base *)object._base()->_cast(VoiceRemoval_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

VoiceRemoval_base *VoiceRemoval_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	VoiceRemoval_base *result;
	result = (VoiceRemoval_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"VoiceRemoval");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new VoiceRemoval_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("VoiceRemoval")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> VoiceRemoval_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("inleft");
	ret.push_back("inright");
	return ret;
}
std::vector<std::string> VoiceRemoval_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outleft");
	ret.push_back("outright");
	return ret;
}

void *VoiceRemoval_base::_cast(unsigned long iid)
{
	if(iid == VoiceRemoval_base::_IID) return (VoiceRemoval_base *)this;
	if(iid == Arts::StereoEffect_base::_IID) return (Arts::StereoEffect_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

VoiceRemoval_stub::VoiceRemoval_stub()
{
	// constructor for subclasses (don't use directly)
}

VoiceRemoval_stub::VoiceRemoval_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string VoiceRemoval_skel::_interfaceName()
{
	return "VoiceRemoval";
}

bool VoiceRemoval_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "VoiceRemoval") return true;
	if (interfacename == "Arts::StereoEffect") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string VoiceRemoval_skel::_interfaceNameSkel()
{
	return "VoiceRemoval";
}

void VoiceRemoval_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::StereoEffect_skel::_buildMethodTable();
}

VoiceRemoval_skel::VoiceRemoval_skel()
{
}

Arts::Object_base* VoiceRemoval::_Creator() {
	return VoiceRemoval_base::_create();
}

unsigned long VoiceRemoval_base::_IID = Arts::MCOPUtils::makeIID("VoiceRemoval");

RawWriter_base *RawWriter_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	RawWriter_base *castedObject = (RawWriter_base *)skel->_cast(RawWriter_base::_IID);
	assert(castedObject);
	return castedObject;
}

RawWriter_base *RawWriter_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return RawWriter_base::_fromReference(r,true);
	return 0;
}

RawWriter_base *RawWriter_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	RawWriter_base *castedObject = (RawWriter_base *)object._base()->_cast(RawWriter_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

RawWriter_base *RawWriter_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	RawWriter_base *result;
	result = (RawWriter_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"RawWriter");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new RawWriter_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("RawWriter")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> RawWriter_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	ret.push_back("inleft");
	ret.push_back("inright");
	return ret;
}
std::vector<std::string> RawWriter_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	ret.push_back("outleft");
	ret.push_back("outright");
	return ret;
}

void *RawWriter_base::_cast(unsigned long iid)
{
	if(iid == RawWriter_base::_IID) return (RawWriter_base *)this;
	if(iid == Arts::StereoEffect_base::_IID) return (Arts::StereoEffect_base *)this;
	if(iid == Arts::SynthModule_base::_IID) return (Arts::SynthModule_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

RawWriter_stub::RawWriter_stub()
{
	// constructor for subclasses (don't use directly)
}

RawWriter_stub::RawWriter_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string RawWriter_skel::_interfaceName()
{
	return "RawWriter";
}

bool RawWriter_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "RawWriter") return true;
	if (interfacename == "Arts::StereoEffect") return true;
	if (interfacename == "Arts::SynthModule") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string RawWriter_skel::_interfaceNameSkel()
{
	return "RawWriter";
}

void RawWriter_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::StereoEffect_skel::_buildMethodTable();
}

RawWriter_skel::RawWriter_skel()
{
}

Arts::Object_base* RawWriter::_Creator() {
	return RawWriter_base::_create();
}

unsigned long RawWriter_base::_IID = Arts::MCOPUtils::makeIID("RawWriter");

ExtraStereoGuiFactory_base *ExtraStereoGuiFactory_base::_create(const std::string& subClass)
{
	Arts::Object_skel *skel = Arts::ObjectManager::the()->create(subClass);
	assert(skel);
	ExtraStereoGuiFactory_base *castedObject = (ExtraStereoGuiFactory_base *)skel->_cast(ExtraStereoGuiFactory_base::_IID);
	assert(castedObject);
	return castedObject;
}

ExtraStereoGuiFactory_base *ExtraStereoGuiFactory_base::_fromString(std::string objectref)
{
	Arts::ObjectReference r;

	if(Arts::Dispatcher::the()->stringToObjectReference(r,objectref))
		return ExtraStereoGuiFactory_base::_fromReference(r,true);
	return 0;
}

ExtraStereoGuiFactory_base *ExtraStereoGuiFactory_base::_fromDynamicCast(const Arts::Object& object)
{
	if(object.isNull()) return 0;

	ExtraStereoGuiFactory_base *castedObject = (ExtraStereoGuiFactory_base *)object._base()->_cast(ExtraStereoGuiFactory_base::_IID);
	if(castedObject) return castedObject->_copy();

	return _fromString(object._toString());
}

ExtraStereoGuiFactory_base *ExtraStereoGuiFactory_base::_fromReference(Arts::ObjectReference r, bool needcopy)
{
	ExtraStereoGuiFactory_base *result;
	result = (ExtraStereoGuiFactory_base *)Arts::Dispatcher::the()->connectObjectLocal(r,"ExtraStereoGuiFactory");
	if(result)
	{
		if(!needcopy)
			result->_cancelCopyRemote();
	}
	else
	{
		Arts::Connection *conn = Arts::Dispatcher::the()->connectObjectRemote(r);
		if(conn)
		{
			result = new ExtraStereoGuiFactory_stub(conn,r.objectID);
			if(needcopy) result->_copyRemote();
			result->_useRemote();
			if (!result->_isCompatibleWith("ExtraStereoGuiFactory")) {
				result->_release();
				return 0;
			}
		}
	}
	return result;
}

std::vector<std::string> ExtraStereoGuiFactory_base::_defaultPortsIn() const {
	std::vector<std::string> ret;
	return ret;
}
std::vector<std::string> ExtraStereoGuiFactory_base::_defaultPortsOut() const {
	std::vector<std::string> ret;
	return ret;
}

void *ExtraStereoGuiFactory_base::_cast(unsigned long iid)
{
	if(iid == ExtraStereoGuiFactory_base::_IID) return (ExtraStereoGuiFactory_base *)this;
	if(iid == Arts::GuiFactory_base::_IID) return (Arts::GuiFactory_base *)this;
	if(iid == Arts::Object_base::_IID) return (Arts::Object_base *)this;
	return 0;
}

ExtraStereoGuiFactory_stub::ExtraStereoGuiFactory_stub()
{
	// constructor for subclasses (don't use directly)
}

ExtraStereoGuiFactory_stub::ExtraStereoGuiFactory_stub(Arts::Connection *connection, long objectID)
	: Arts::Object_stub(connection, objectID)
{
	// constructor to create a stub for an object
}

std::string ExtraStereoGuiFactory_skel::_interfaceName()
{
	return "ExtraStereoGuiFactory";
}

bool ExtraStereoGuiFactory_skel::_isCompatibleWith(const std::string& interfacename)
{
	if (interfacename == "ExtraStereoGuiFactory") return true;
	if (interfacename == "Arts::GuiFactory") return true;
	if (interfacename == "Arts::Object") return true;
	return false;
}

std::string ExtraStereoGuiFactory_skel::_interfaceNameSkel()
{
	return "ExtraStereoGuiFactory";
}

void ExtraStereoGuiFactory_skel::_buildMethodTable()
{
	Arts::Buffer m;
	m.fromString(
        "MethodTable:",
		"MethodTable"
	);
	Arts::GuiFactory_skel::_buildMethodTable();
}

ExtraStereoGuiFactory_skel::ExtraStereoGuiFactory_skel()
{
}

Arts::Object_base* ExtraStereoGuiFactory::_Creator() {
	return ExtraStereoGuiFactory_base::_create();
}

unsigned long ExtraStereoGuiFactory_base::_IID = Arts::MCOPUtils::makeIID("ExtraStereoGuiFactory");

static Arts::IDLFileReg IDLFileReg_artseffects("artseffects",
    "IDLFile:00000001000000000000000000000000040000000c45787472615374657265"
    "6f000000000100000013417274733a3a53746572656f45666665637400000000000000"
    "00010000000a696e74656e736974790000000006666c6f617400000000130000000000"
    "000000000000000000000d566f69636552656d6f76616c000000000100000013417274"
    "733a3a53746572656f4566666563740000000000000000000000000000000000000000"
    "0a526177577269746572000000000100000013417274733a3a53746572656f45666665"
    "6374000000000000000000000000000000000000000016457874726153746572656f47"
    "7569466163746f7279000000000100000011417274733a3a477569466163746f727900"
    "0000000000000000000000000000000000000000"
);
